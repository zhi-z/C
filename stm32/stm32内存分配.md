# stm32内存分配

## **bss段：**

　　**bss段（bss segment）**通常是指用来存放程序中未初始化的全局变量的一块内存区域。

　　bss是英文Block Started by Symbol的简称。

　　bss段属于静态内存分配。 

 

## **data段：**

　　**数据段（data segment）**通常是指用来存放程序中已初始化的全局变量的一块内存区域。

　　数据段属于静态内存分配。 

 

## **text段：**

　　**代码段（code segment/text segment）**通常是指用来存放程序执行代码的一块内存区域。

　　这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。

　　在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。 

 

## **堆（heap）：**

　　堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。

　　当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；

　　当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。

 

## **栈(stack)**：

　　 栈又称堆栈，是用户存放程序临时创建的局部变量，

　　也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。

　　除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。

　　由于栈的先进先出(FIFO)特点，所以栈特别方便用来保存/恢复调用现场。

　　从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。 

------

**一个程序本质上都是由 bss段、data段、text段三个组成的。**

　　这样的概念，不知道最初来源于哪里的规定，但在当前的计算机程序设计中是很重要的一个基本概念。

　　而且在嵌入式系统的设计中也非常重要，牵涉到嵌入式系统运行时的内存大小分配，存储单元占用空间大小的问题。

​    在采用段式内存管理的架构中（比如intel的80x86系统），bss段通常是指用来存放程序中未初始化的全局变量的一块内存区域，

　　一般在初始化时bss 段部分将会清零。bss段属于静态内存分配，即程序一开始就将其清零了。

​    比如，在C语言之类的程序编译完成之后，已初始化的全局变量保存在.data 段中，未初始化的全局变量保存在.bss 段中。

　　text和data段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载；

　　而bss段不在可执行文件中，由系统初始化。



**首先，先看一下stm32的存储器结构。**

****Flash，SRAM寄存器和输入输出端口被组织在同一个4GB的线性地址空间内。可访问的存储器空间被分成8个主要块，每个块为512MB。

FLASH存储下载的程序。

SRAM是存储运行程序中的数据。

所以，只要你不外扩存储器，写完的程序中的所有东西也就会出现在这两个存储器中。

这是一个前提！





**堆栈的认知**

1.     STM32中的堆栈。

这个我产生过混淆，导致了很多逻辑上的混乱。首先要说明的是单片机是一种集成电路芯片，集成CPU、RAM、ROM、多种I/O口和中断系统、定时器/计数器等功能。CPU中包括了各种总线电路，计算电路，逻辑电路，还有各种寄存器。Stm32有通用寄存器 R0‐ R15 以及一些特殊功能寄存器,其中包括了堆栈指针寄存器。当stm32正常运行程序的时候，来了一个中断，CPU就需要将寄存器中的值压栈到RAM里，然后将数据所在的地址存放在堆栈寄存器中。等中断处理完成退出时，再将数据出栈到之前的寄存器中，这个在C语言里是自动完成的。

2.     编程中的堆栈。

在编程中很多时候会提到堆栈这个东西，准确的说这个就是RAM中的一个区域。我们先来了解几个说明:

(1) 程序中的所有内容最终只会出现在flash，ram里（不外扩）。

(2) 段的划分，是将类似数据种类存储在一个区域里，方便管理，但正如上面所说，不管什么段的数据，都是最终在flash和ram里面。

C语言上分为栈、堆、bss、data、code段。具体每个段具体是存储什么数据的，直接百度吧。重点分析一下STM32以及在MDK里面段的划分。

MDK下Code, RO-data,RW-data,ZI-data这几个段:

Code是存储程序代码的。

RO-data是存储const常量和指令。

RW-data是存储初始化值不为0的全局变量。

ZI-data是存储未初始化的全局变量或初始化值为0的全局变量。

Flash=Code + RO Data + RW Data;

RAM= RW-data+ZI-data;

这个是MDK编译之后能够得到的每个段的大小，也就能得到占用相应的FLASH和RAM的大小，但是还有两个数据段也会占用RAM，但是是在程序运行的时候，才会占用，那就是堆和栈。在stm32的启动文件.s文件里面，就有堆栈的设置，其实这个堆栈的内存占用就是在上面RAM分配给RW-data+ZI-data之后的地址开始分配的。

堆:是编译器调用动态内存分配的内存区域。

栈:是程序运行的时候局部变量的地方，所以局部变量用数组太大了都有可能造成栈溢出。

堆栈的大小在编译器编译之后是不知道的，只有运行的时候才知道，所以需要注意一点，就是别造成堆栈溢出了。。。不然就等着hardfault找你吧。

3.     OS中的堆栈及其内存管理。

嵌入式系统的堆栈，不管是用什么方法来得到内存，感觉他的方式都和编程中的堆差不多。目前我知道两种获得内存情况：

（1）用庞大的全局变量数组来圈住一块内存，然后将这个内存拿来进行内存管理和分配。这种情况下，堆栈占用的内存就是上面说的：如果没有初始化数组，或者数组的初始化值为0，堆栈就是占用的RAM的ZI-data部分；如果数组初始化值不为0，堆栈就占用的RAM的RW-data部分。这种方式的好处是容易从逻辑上知道数据的来由和去向。

（2）就是把编译器没有用掉的RAM部分拿来做内存分配，也就是除掉RW-data+ZI-data+编译器堆+编译器栈后剩下的RAM内存中的一部分或者全部进行内存管理和分配。这样的情况下就只需要知道内存剩下部分的首地址和内存的尾地址，然后要用多少内存，就用首地址开始挖，做一个链表，把内存获取和释放相关信息链接起来，就能及时的对内存进行管理了。内存管理的算法多种多样，不详说，这样的情况下：OS的内存分配和自身局部变量或者全局变量不冲突，之前我就在这上面纠结了很久，以为函数里面的变量也是从系统的动态内存中得来的。这种方式感觉更加能够明白自己地址的开始和结束。

这两种方法我感觉没有谁更高明，因为只是一个内存的获取方式，高明的在于内存的管理和分配。

 

keil编译后会有一行：Program Size:Code=xxxRO-data=xxx RW-data=xxx ZI-data=xxx

Code 代表执行的代码，程序中所有的函数都位于此处。

RO-data 代表只读数据，程序中所定义的全局常量数据和字符串都位于此处。

RW-data 代表已初始化的读写数据，程序中定义并且初始化的全局变量和静态变量位于此处。

ZI-data 代表未初始化的读写数据，程序中定义了但没有初始化的全局变量和静态变量位于此处。ZI英语是zero initial，就是程序中用到的变量并且被系统初始化为0的变量的字节数，keil编译器默认是把你没有初始化的变量都赋值一个0，这些变量在程序运行时是保存在RAM中的。

2.如果你查看.map文件，如下例子：

==============================================================================

​    Total RO  Size (Code + RO Data)                 2980 (   2.91kB)
    Total RW  Size (RW Data + ZI Data)               104 (   0.10kB)
    Total ROM Size (Code + RO Data + RW Data)       2988 (   2.92kB)

==============================================================================

Total ROM Size (Code + RO Data + RW Data)这样所写的程序占用的ROM的字节总数，也就是说程序所下载到ROM flash 中的大小。为什么Rom中还要存RW，因为掉电后RAM中所有数据都丢失了，每次上电RAM中的数据是被重新赋值的，每次这些固定的值就是存储在Rom中的，为什么不包含ZI段呢，是因为ZI数据都是0，没必要包含，只要程序运行之前将ZI数据所在的区域一律清零即可，包含进去反而浪费存储空间。

 

实际上，ROM中的指令至少应该有这样的功能：
       1. 将RW从ROM中搬到RAM中，因为RW是变量，变量不能存在ROM中。
       2. 将ZI所在的RAM区域全部清零，因为ZI区域并不在Image中，所以需要程序根据编译器给出的ZI地址及大小来将相应得RAM区域清零。ZI中也是变量，同理：变量不能存在ROM中。
       在程序运行的最初阶段，RO中的指令完成了这两项工作后C程序才能正常访问变量。否则只能运行不含变量的代码。



## 参考文献：

https://www.cnblogs.com/yanghong-hnu/p/4705755.html